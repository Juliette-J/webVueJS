TOKEN (ex : JWT, OAUTH?)

HTTPS --> plus sécurisé que HTTP

faille CSRF : utiliser machine d'un client pour récupérer infos réseau local (malveillant)

Cores Policy ? => restriction de connection au serveur = que noms de domaine listés qui peuvent accéder au serveur

Synchrone (commandes lues l'une après l'autre) VS Asynchrone (avec des promises) 

--> FETCH

const myP = new P(
	(resolve, reject) => {
		veryLongTimeFunc()
		resolve()
	}
)

	--------------------

myP().then(
	() => {console.log("Done !")}
).except( 
	() => {console.log("Failed !")}
)

	____________________

fetch("https:://...").then((response) => foo(response))


--> ASYNC/AWAIT

const myAsuncF async () => {
	... // Long op
	return "Done"
}

	----------------------

const myF = async () => {
	const data = await myAsyncF()
	console.log(data)
}

	______________________

response = await fetch("https://...)

if (response.status == 200)
	const data = response.json()
else
	new Error(response.statusText)

	______________________

fetch("https://..." , {
	method: "", 
	headers: {
		"Content-Type": "application/json",
		'Authorisation': 'Bearer ' + myToken,
	},
	body: JSON.stringify(myData)
})

___________________________________________________________

DIRECTIVES
___________________________________________________________

<template>
   <p v-show="isVisible == true">invisible</p>
   <p>visible</p>

   <p v-if:"exist">doesn't exist<p/>
   <p v-else-if:"exist2">doesn't exist<p/>
   <p v-else>doesn't exist<p/>

   <div v-for:"text in texts" :key="text">
	<p> {{ text }} </p>
   </div>

   <div v-for:"text in texts" :key="user.id">
	<p> {{ user.firstname }} </p>
   </div>

   <div v-bind:id="'list-' + id">
	<a v-bind:href="url">Link
	<button v-bind:disabled= "isButtonDisabled?">button</button>
   </div>

   <button v-bind:class="{valid: isValid, invalid: !isValid}">button</button>
   <div v-bind:style="{color: activeColor, fontSize: fontSize + 'px' }"></div>

</template>

<template>
   <DogCard v-for="dog in dogsData" :key="dog.id" :firstname="dog.name" :pictureURL=""> 
</template>

<script>
   export default {
     ... ,
      data () {
         return {
           isVisible: false, // ou isLoading par exemple
           exist: false,
           exist2: true,
           texts: ["Hello", "World"],
           users: [ 
              {id: 0, firstname:"John"},
              {id: 1, firstname:"Jules"}
           ]
         }
      }
   }
</script>

+ setIntervall() (JS)

______________________________________________________________________________________

EVENT & FORMULAIRES
______________________________________________________________________________________

/* --- NPM --- */

ex: 
   npm init // configure un projet Node.js

+ package.json > "devDependancies" : lib dont seul le dev à besoin (ex: compilateur) et pas besoin d'être dans le code final

exs:
   npm install myLib // install in the current project
   npm install -g myLib // install globally on the machine
   npm uninstall myLib // uninstall the lib in the current project

/* --- FORM --- */

<template>
	<input type="text" v-model="search" placeholder>
	<label for= > ... </label>
	<select v-model="dog-sort" id=>
		<option value="A"> ... </option>
		<option value="B"> ... </option>
	</select>
</template>

<script>
... 
    data() {
	return {
		dogData: [], 
		search: ""
	}
    }
</script>

/* --- EVENTS --- */

// AVANT

<form>
	<button onclick="sayHello()" value=""> ... </button>
</form>

el.addEventListener("click", sayHello)

// NOW

<template>
	<button v-on:click="doStuff"> ... </button>
	// <button @click="doStuff"> ... </button>
<template>

<script>
	...
	methods: {
		doStuff : fuction(event) {
			event.target.text = "My button clicked"
		}
	}
</script>

ex: click, dbclick, mouseenter, mouseleave, mouseover, input, change (modifié par l'utilisateur)

// Callback inline

<template>
	<button v-on:click="doStuff('clicked', $event)"> ... </button>
<template>

<script>
	...
	methods: {
		doStuff : fuction(word, event) {
			event.target.text = "My button" + word
		}
	}
</script>

// Modificateurs

ex: .stop (arrêter la propagation d'event), .prevent (empêche les comportements par défaut/natifs)

__________________________________________________________________________________________________

DONNEES CALCULEE
__________________________________________________________________________________________________

// Méthodes

--> array.forEach( (element) => console.log(element) )
--> nb.sort( (a, b) => a - b ) où nb == tab de nombres
	/!\ s'applique directement sur le tab nb (pas de valeur de retour)
--> map : générer une nvlle collection à partir d'une autre => array2 = array1.map( x => 2*x )
--> filter : retirer cases en fonction critères => result = words.filter( word => word.length() > 6 )
--> reduce : array.reduce( (prevValue, currentValue) => prevValue + currentValue, initialValue ) 
--> nb.includes('...') => retourne un booléen
--> array.reverse()
--> array.join('_') => fait une chîne de caractères où mots joints par "_"

// Données calculées

--> déterminer une variable qui dépend d'autres valeurs + s'actualise
     => en 'lecture seule'

ex : 
     <template>
         <p>{{ number 1 }} + {{ number 2 }} = {{ sum }}</p>
     </template>

     <script>
         ... , 
         computed: {
               sum: function() {
                    return this.number1 + this.number2
               }
          },
     <script>

   ---------------------------------------------------------

=> tri instantané tab en fonction données formulaire :

<script>
     computed: {
          dogsOrganizedData: function() {
               ... tri par exple
	       let data = this.dogsData
	       const flield = ['AZName', 'ZAName'].includes(this.dogSortType) ? "name" : "breed"
	       const reversed = ["ZAName", "ZABreed"].includes(this.dogSortType)
	       // const filterFunct = (a) => a.name.toLowerCase().includes(this.search.toLowerCase())
	       const comparator = (a,b) => a[field].localCompare(b[field])
	       // data = this.dogsData.filter(filterFunct)
               data = this.dogsData.sort(comparator)
	       if (reversed) data = data.reverse()
	       return data
    	  }
          data () {
	       search: "",
               dogsSortType: "AZName"
          }
</script>

_______________________________________________________________________________________________________

STOCKAGE DONNEES (COTE CLIENT)
_______________________________________________________________________________________________________

BundlerJS

--> pas un compilateur / interpréteur
--> transpilation entre langages : transformation de syntaxe d'un fichier

1. Rassembler fichiers concernés
2. Effectuer traitement unitaire
3. Fusionner fichiers
4. Effectuer traitement global
5. Regrouper fichiers de sortie


Webpack

ex: 'npm install --save-dev webpack' puis configurer webpack.config.js
    './node_modules/.bin/webpack' OU mettre ' "build": "webpack" ' dans champ "script" et faire 'npm run build'

ex: 
module.export = {
	...,
	entry: {
		index: {".src/index.js"},
	},
	output: {
		path: path.join(_dir.name, ""),
 		filename: "bundle.js",
		publicPath: "/",
	}
}

          --------------------------

module.export = {
	...,
	resolve: {
		alias: {
			'@img': path.resolve('./public/assets/picture'),
		},
	},
}

          --------------------------

module.export = {
	...,
	module: {
		rules: [ {
			test: /\.js$/,
			exclude: ...,
			use: {
				loader: 'babel-loader',
				options: {
					presets: ...,
				}
			}
		} ],
	},
}

          --------------------------

module.export = {
	...,
	plugins: [
		new UglifyJSPlugin()
	],
}


STOCKAGE COTE CLIENT

--> pour données pas capitales
--> pour données temporaires
--> ppur aider à l'authentification

3 méthodes :
   - local
   - session
   - cookies

Local :
   - stockage indéfini
   - peuvent être supprimées facilement (vider cache)
   - jusqu'à env 10MB par site
   - utiles pour pref utilisateur

--> Décla : localStorage.setItem("key", "value")

--> Récup : localStorage.getItem("key")

Session:
   - Supprimé automatiquement à la fermeture du navigateur
   MAIS persiste au changement de page ou rafraîchissement
   - jusqu'à saturation machine
   - pour données utiles entre pages du site

Cookies :
   - persiste jusqu'à date d'expiration
   - accessible côté client et côté serveur (dès première requête)
   - peuvent être partagés sur plusieurs sites
   - authentification et traçage de l'utilisateur
   - la limite de stockage dépend du navigateur

--> Décla : document.cookie = "key=value; expires=Thu, 03 Feb 2022 00:00:00 UTC"

--> Supp : éditer cookie avec date passée

--> Récup : créer fonction getCookie(name) qui extrait infos de chaine de caractères

==> STOCKER INFOS DANS NOTRE PROJET

ex :
	localStorage.setItem("search", this.search)
	localStorage.setItem("dogsSortType", this.dogsSortType)

_____________________________________________________________________________________

OBSERVATEURS & EVENT PERSONALISES
_____________________________________________________________________________________

Observateur

--> surveiller édition données
-->

ex: 
	export default: {
	   ...
	   watch: {
		username: funct(newUserName, oldUserName) {
			console.log(),
		}
   	   }
	}

export default: {
	   ...
	   watch: {
		search: funct(newSearch) {
			localStorage.setItem("search", newSearch)
		},
		dogsType: ...
   	   }
	}

--> Hooks : pour comportement générique, commun à toutes les modifs de données
--> Données calculées : qd modif une var modifie d'autres var liées au composant courant
--> Observateur : qd modif données a action distante (sur d'autres composants)

Events personalisés

+ flux unilatéral de données

ex: 
  Child
	exp def {
	   emits: { "eventName"},
		methods:
		   emitCustomEvent: funct() { this.$emit("eventName", "Hello World") }
	}

   Parent

--> replace event par défaut

Modif props
ex: 
  Child
	exp def {
	   emits: { "update:myProps"},
		methods:
		   emitCustomEvent: funct() { this.$emit("eventName", "Hello World") },
	   props: { myProps: {type: String} },
	   methods: 
	}

   Parent
	<ChildComponent v-model:myProps="myData">


